import { type Require, type Servers, generateSignature } from "./utils";

export interface TKassaOptions {
	/**
	 * Сервер, куда будут отправляться запросы.
	 *
	 * * `https://securepay.tinkoff.ru` - продакшн
	 * * `https://rest-api-test.tinkoff.ru` - тестовая среда
	 *
	 * @default "https://securepay.tinkoff.ru"
	 */
	server?: Servers;
}

export class TKassa {
	terminalKey: string;
	password: string;
	options: Require<TKassaOptions, "server">;

	constructor(terminalKey: string, password: string, options?: TKassaOptions) {
		this.terminalKey = terminalKey;
		this.password = password;

		this.options = {
			server: "https://securepay.tinkoff.ru",
			...options,
		};
	}

	private async request(
		url: string,
		data: Record<string, unknown>,
		method: "POST" | "GET" = "POST",
	) {
		const signature = generateSignature(data, this.password);

		const response = await fetch(this.options.server + url, {
			method,
			...(method === "POST"
				? {
						headers: {
							"content-type": "application/json",
							"user-agent":
								"Т-Касса SDK for Node.js (https://github.com/kravetsone/t-kassa-api)",
						},
						body: JSON.stringify({
							Token: signature,
						}),
					}
				: {}),
		});
	}

	/** @generated start-generate-methods */
	/**
	 * * Метод инициирует платежную сессию
	 *
	 *
	 * @tags Стандартный платеж, Оплата через YandexPay
	 * @summary Инициализация платежа
	 */
	init() {
		return 1;
	}
	/**
	 *
	 *
	 * @tags Оплата через T‑Pay, Оплата через СБП
	 * @summary Инициировать платеж в виджете
	 */
	initPayments() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Проверяет поддерживаемую версию 3DS протокола по карточным данным из входящих
	 *  параметров
	 *
	 *  При определении второй версии, возможно в ответе получение данных для прохождения
	 *  дополнительного метода `3DS Method`, который позволяет эмитенту собрать данные браузера
	 *  клиента — это может быть полезно при принятии решения в пользу **Frictionless Flow**
	 *  (аутентификация клиента без редиректа на страницу ACS) <br>
	 *
	 *
	 * @tags Стандартный платеж
	 * @summary Проверка версии 3DS
	 */
	check3dsVersion() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Метод подтверждает платеж передачей реквизитов, а также списывает средства
	 *  с карты клиента при одностадийной оплате и блокирует указанную сумму при
	 *  двухстадийной. Используется, если у площадки есть сертификация PCI DSS и
	 *  собственная платежная форма
	 *
	 *
	 * @tags Стандартный платеж
	 * @summary Подтверждение платежа
	 */
	finishAuthorize() {
		return 1;
	}
	/**
	 * * Метод для списания заблокированных денежных средств. Используется при двухстадийном проведении платежа. Применим только к платежам в статусе **AUTHORIZED**. Статус транзакции перед разблокировкой
	 * выставляется в **CONFIRMING**. Сумма списания может быть меньше или равна сумме авторизации.
	 * > Подробнее про двухстадийный платеж можно прочитать в разделе [Сценарии платежа](https:\/\/www.tbank.ru\/kassa\/dev\/payments\/#tag\/Scenarii-oplaty-po-karte\/Scenarii-platezha) — "Двухстадийный платеж"
	 *
	 *
	 * @tags Двухстадийный платеж
	 * @summary Подтверждение платежа
	 */
	confirm() {
		return 1;
	}
	/**
	 * * Отменяет платежную сессию. В зависимости от статуса платежа переводит его в следующие состояния:
	 * * NEW — CANCELED
	 * * AUTHORIZED — PARTIAL_REVERSED — если отмена не на полную сумму;
	 * * AUTHORIZED — REVERSED — если отмена на полную сумму;
	 * * CONFIRMED — PARTIAL_REFUNDED — если отмена не на полную сумму;
	 * * CONFIRMED — REFUNDED — если отмена на полную сумму.
	 *
	 * Для платежей «в Рассрочку» отмена доступна только из статуса AUTHORIZED <br>
	 * Для платежей «Долями» если операция в статусе CONFIRMED или PARTIAL_REFUNDED будет осуществлен частичный либо полный возврат <br>
	 * Если платеж находился в статусе **AUTHORIZED** производится отмена холдирования средств на карте
	 * клиента. При переходе из статуса **CONFIRMED** — возврат денежных средств на карту клиента
	 *
	 *
	 * @tags Отмена платежа
	 * @summary Отмена платежа
	 */
	cancel() {
		return 1;
	}
	/**
	 * * # Схема проведения рекуррентного платежа
	 *
	 * ## Описание
	 *
	 * Осуществляет рекуррентный (повторный) платеж — безакцептное списание денежных средств со счета банковской карты клиента.
	 * Для возможности его использования клиент должен совершить хотя бы один платеж в пользу Мерчанта, который должен быть указан как рекуррентный (см. параметр Recurrent методе **Init**), фактически являющийся первичным. По завершении оплаты в нотификации на AUTHORIZED или CONFIRMED будет передан параметр `RebillId`.<br>
	 * В дальнейшем для совершения рекуррентного платежа Мерчант должен вызвать метод **Init**, указать нужную сумму для списания в параметре `Amount`, а затем без переадресации на PaymentURL вызвать метод **Charge** для оплаты по тем же самым реквизитам и передать параметр `RebillId`, полученный при совершении первичного платежа.<br>
	 * Метод **Charge** работает по одностадийной и двухстадийной схеме оплаты. Чтобы перейти на двухстадийную схему нужно переключить терминал в [Личном кабинете](https:\/\/business.tbank.ru\/oplata\/main), а также написать обращение на <acq_help@tinkoff.ru> с просьбой переключить схему рекуррентов.
	 *
	 * >По умолчанию метод Charge отключен. Для его включения на DEMO-терминале нужно написать обращение на <acq_help@tinkoff.ru>, а на боевом терминале — обратиться к своему персональному менеджеру
	 *
	 * При проведении рекуррентного платежа учитывать взаимосвязь атрибута RebillId в методе \/Charge с:
	 *   * Значением атрибута OperationInitiatorType в методе \/Init;
	 *   * Значением атрибута Reccurent в методе \/Init;
	 *   * Типом терминала, используемом для проведения операций (ECOM\/AFT).
	 *
	 * Наглядно допустимые сценарии взаимосвязи описаны в таблице:
	 * |CIT\/MIT|Тип операции|OperationInitiator в \/Init|RebillId в \/Charge|Recurrent в \/Init|AFT терминал|ECOM терминал|
	 * |---|---|---|---|---|---|---|
	 * |CIT|Credential-Not-Captured|0|null|N|Разрешено|Разрешено|
	 * |CIT|Credential-Captured|1|null|Y|Разрешено|Разрешено|
	 * |CIT|Credential-on-File|2|not null|N|Запрещено|Разрешено|
	 * |MIT|Credential-on-File, Recurring|R|not null|N|Запрещено|Разрешено|
	 * |MIT|Credential-on-File, Installment|I|not null|N|Разрешено|Запрещено|
	 *
	 * В случае передачи значений атрибутов не соответствующих таблице — MAPI вернет ошибку 1126
	 * (Несопоставимые значения rebillId или Recurrent с переданным значением OperationInitiatorType)
	 *
	 * ## Одностадийная оплата
	 *
	 * 1. Совершить родительский платеж путем вызова **Init** с указанием дополнительных параметров `Recurrent=Y` и `CustomerKey`.
	 * 2. Переадресовать клиента на `PaymentUrl` (только <span style="color:#900C3F">для Мерчантов без PCI DSS<\/span>).
	 * 3. После оплаты заказа клиентом в нотификации на статус **AUTHORIZED** или **CONFIRMED** будет передан параметр `RebillId`, который необходимо сохранить.
	 * 4. Спустя некоторое время для совершения рекуррентного платежа необходимо вызвать метод **Init** со стандартным набором параметров (параметры `Recurrent` и `CustomerKey` здесь не нужны).
	 * 5. Получить в ответ на **Init** параметр `PaymentId`.
	 * 6. Вызвать метод **Charge** с параметром `RebillId`, полученным в п.3, и параметром `PaymentId`, полученным в п.5. При успешном сценарии операция перейдет в статус CONFIRMED.
	 *
	 *
	 * ## Двухстадийная оплата
	 *
	 * 1. Совершить родительский платеж путем вызова **Init** с указанием дополнительных параметров `Recurrent=Y` и `CustomerKey`.
	 * 2. Переадресовать клиента на `PaymentUrl` (только <span style="color:#900C3F">для Мерчантов без PCI DSS<\/span>).
	 * 3. После оплаты заказа клиентом в нотификации на статус **AUTHORIZED** или **CONFIRMED** будет передан параметр RebillId, который необходимо сохранить.
	 * 4. Спустя некоторое время для совершения рекуррентного платежа необходимо вызвать метод **Init** со стандартным набором параметров (параметр `Recurrent` и `CustomerKey` здесь не нужны).
	 * 5. Получить в ответ на **Init** параметр `PaymentId`.
	 * 6. Вызвать метод **Charge** с параметром `RebillId`, полученным в п.3, и параметром `PaymentId`, полученным в п.5. При успешном сценарии операция перейдет в статус **AUTHORIZED**. Денежные средства будут заблокированы на карте клиента.
	 * 7. Вызвать метод **Confirm** для подтверждения платежа.
	 *
	 *
	 * @tags Рекуррентный платеж
	 * @summary Автоплатеж
	 */
	chargePCI() {
		return 1;
	}
	/**
	 * * Метод возвращает статус платежа
	 *
	 *
	 * @tags Стандартный платеж
	 * @summary Получение статуса платежа
	 */
	getState() {
		return 1;
	}
	/**
	 * * Регистрирует клиента в связке с терминалом
	 *
	 * > Возможна автоматическая привязка клиента и карты, по которой был совершен платеж, при
	 * передаче параметра `CustomerKey` в методе **Init**. Это можно использовать для сохранения и
	 * последующего отображения клиенту замаскированного номера карты, по которой будет совершен
	 * рекуррентный платеж
	 *
	 *
	 * @tags Методы работы с клиентами
	 * @summary Регистрация клиента
	 */
	addCustomer() {
		return 1;
	}
	/**
	 * * Возвращает данные клиента, сохраненные в связке с терминалом
	 *
	 *
	 * @tags Методы работы с клиентами
	 * @summary Получение данных клиента
	 */
	getCustomer() {
		return 1;
	}
	/**
	 * * Удаляет сохраненные данные клиента
	 *
	 *
	 * @tags Методы работы с клиентами
	 * @summary Удаление данных клиента
	 */
	removeCustomer() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Метод инициирует привязку карты к клиенту.
	 *  В случае успешной привязки переадресует клиента на `Success Add Card URL`,
	 *  в противном случае на `Fail Add Card URL`.
	 *  Можно использовать форму Т‑Кассы, возможно заменить на кастомную форму.
	 *
	 *
	 * @tags Методы работы с картами
	 * @summary Инициализация привязки карты к клиенту
	 */
	addCard() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Завершает привязку карты к клиенту.
	 *  В случае успешной привязки переадресует клиента на **Success Add Card URL**
	 *  в противном случае на **Fail Add Card URL**.
	 *  Для прохождения 3DS второй версии перед вызовом метода должен быть вызван **\/v2\/check3dsVersion**
	 *  и выполнен **3DS Method**, который является обязательным при прохождении **3DS** по протоколу версии
	 *  2.0.
	 *
	 *
	 * @tags Методы работы с картами
	 * @summary Привязка карты
	 */
	attachCard() {
		return 1;
	}
	/**
	 * * `Для мерчантов с PCI DSS`
	 *  <br> Метод возвращает статус привязки карты
	 *
	 *
	 * @tags Методы работы с картами
	 * @summary Статус привязки карты
	 */
	getAddCardState() {
		return 1;
	}
	/**
	 * * Возвращает список всех привязанных карт клиента, включая удаленные
	 *
	 *
	 * @tags Методы работы с картами
	 * @summary Список карт клиента
	 */
	getCardList() {
		return 1;
	}
	/**
	 * * Метод удаляет привязанную карту клиента
	 *
	 *
	 * @tags Методы работы с картами
	 * @summary Удаление привязанной карты клиента
	 */
	removeCard() {
		return 1;
	}
	/**
	 * * Метод регистрирует QR и возвращает информацию о нем.
	 * Должен быть вызван после вызова метода **Init**
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Формирование QR
	 */
	getQr() {
		return 1;
	}
	/**
	 * * Метод предназначен для подтверждения карты путем блокировки случайной суммы
	 *
	 * @tags Методы работы с привязанными картами и клиентами
	 * @summary SubmitRandomAmount
	 */
	submitRandomAmount() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Осуществляет проверку результатов прохождения 3-D Secure и при успешном результате
	 *  прохождения 3-D Secure подтверждает инициированный платеж.
	 *  При использовании одностадийной оплаты осуществляет списание денежных средств с карты
	 *  клиента. <br>
	 *  При двухстадийной оплате осуществляет блокировку указанной суммы на карте клиента<br>
	 *
	 *  *Формат запроса*: `x-www-form-urlencoded` <br>
	 *
	 *  После получения на `TermUrl` мерчанта ответа ACS с результатами прохождения 3-D Secure необходимо
	 *  сформировать запрос к методу **Submit3DSAuthorization**
	 *
	 *
	 * @tags Прохождение 3DS
	 * @summary Подтверждение прохождения 3DS v1.0
	 */
	submit3DSAuthorization() {
		return 1;
	}
	/**
	 * * `Для Мерчантов с PCI DSS`
	 *  <br> Осуществляет проверку результатов прохождения 3-D Secure v2 и при успешном результате
	 *  прохождения 3-D Secure v2 подтверждает инициированный платеж.
	 *  При использовании одностадийной оплаты осуществляет списание денежных средств с карты
	 *  клиента.
	 *  При двухстадийной оплате осуществляет блокировку указанной суммы на карте клиента.
	 *
	 *  *Формат запроса*: `x-www-form-urlencoded` <br>
	 *
	 *  После получения на `cresCallbackUrl` Мерчанта ответа ACS с результатами прохождения 3-D Secure необходимо
	 *  сформировать запрос к методу **Submit3DSAuthorizationV2**
	 *
	 *
	 * @tags Прохождение 3DS
	 * @summary Подтверждение прохождения 3DS v2.1
	 */
	submit3DSAuthorizationV2() {
		return 1;
	}
	/**
	 * * Метод определения возможности проведения платежа T‑Pay на терминале и устройстве
	 *
	 *
	 * @tags Оплата через T‑Pay
	 * @summary Статус
	 */
	status() {
		return 1;
	}
	/**
	 * * Метод получения Link для безусловного редиректа на мобильных устройствах
	 *
	 *
	 * @tags Оплата через T‑Pay
	 * @summary Получение ссылки
	 */
	link() {
		return 1;
	}
	/**
	 * * Метод получения QR для десктопов
	 *
	 *
	 * @tags Оплата через T‑Pay
	 * @summary Получение QR
	 */
	qR() {
		return 1;
	}
	/**
	 * * Метод получения QR для десктопов
	 *
	 *
	 * @tags Оплата через SberPay
	 * @summary Получение QR
	 */
	sberPayQR() {
		return 1;
	}
	/**
	 * * Получение ссылки
	 *
	 *
	 * @tags Оплата через SberPay
	 * @summary Получение ссылки
	 */
	sberPaylink() {
		return 1;
	}
	/**
	 * * Передача уведомления о событии платежного виджета T‑Pay + T‑ID
	 *
	 * @tags Оплата через T‑Pay
	 * @summary Передача уведомления о событии
	 */
	tPayEvent() {
		return 1;
	}
	/**
	 * * Метод возвращает список участников куда может быть осуществлен возврат платежа, совершенного
	 * по QR
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Список банков-пользователей QR
	 */
	qrMembersList() {
		return 1;
	}
	/**
	 * * Метод инициирует привязку счета клиента к магазину
	 * и возвращает информацию о нем
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Привязка счёта к магазину
	 */
	addAccountQr() {
		return 1;
	}
	/**
	 * * Метод возвращает статус привязки счета клиента по магазину
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Получение статуса привязки счета к магазину
	 */
	getAddAccountQrState() {
		return 1;
	}
	/**
	 * * Метод возвращает список привязанных счетов клиента по магазину
	 *
	 * @tags Оплата через СБП
	 * @summary Получение списка счетов, привязанных к магазину
	 */
	getAccountQrList() {
		return 1;
	}
	/**
	 * * Проведение платежа по привязанному счету по QR через СБП.
	 * Для возможности его использования клиент должен совершить успешную привязку счета с
	 * помощью метода **AddAccountQr**. После вызова метода будет отправлена нотификация на Notification
	 * URL о привязке счета , в которой будет указан AccountToken.
	 * Для совершения платежа по привязанному счету Мерчант должен вызвать метод **Init**, в котором поля
	 * **Recurrent= Y** и **DATA= {“QR”:“true”}**, а затем вызвать метод **ChargeQr** для оплаты по тем же самым
	 * реквизитам и передать параметр **AccountToken**, полученный после привязки счета по QR в
	 * нотификации.
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Автоплатеж по QR
	 */
	chargeQr() {
		return 1;
	}
	/**
	 * * Тестовая платежная сессия с предопределенным статусом по СБП
	 *
	 * @tags Оплата через СБП
	 * @summary Создание тестовой платежной сессии
	 */
	sbpPayTest() {
		return 1;
	}
	/**
	 * * Возвращает статус возврата платежа по СБП
	 *
	 *
	 * @tags Оплата через СБП
	 * @summary Получение статуса возврата
	 */
	getQRState() {
		return 1;
	}
	/**
	 * * Метод возвращает статус заказа
	 *
	 *
	 * @tags Стандартный платеж
	 * @summary Получение статуса заказа
	 */
	checkOrder() {
		return 1;
	}
	/**
	 * * Метод позволяет отправить закрывающий чек в кассу.
	 * Условия работы метода:
	 * 1. Закрывающий чек может быть отправлен если платежная сессия по первому чеку находится в
	 *   статусе **CONFIRMED**.
	 * 2. В платежной сессии был передан объект `Receipt`.
	 * 3. В объекте `Receipt` был передан хотя бы один объект `Receipt.Items.PaymentMethod` =
	 *   `full_prepayment` или `prepayment` или `advance`.
	 *
	 *
	 * @tags Методы работы с чеками
	 * @summary Закрывающий чек в кассу
	 */
	sendClosingReceipt() {
		return 1;
	}
	/**
	 * * Метод реализуется на стороне Мерчанта для получения уведомлений об изменении статуса платежа
	 *
	 * > **Нотификации о привязке (NotificationAddCard)**
	 * `Для Мерчантов с PCI DSS`
	 * <br> Уведомления магазину о статусе выполнения метода привязки карты `AttachCard`.
	 * После успешного выполнения метода `AttachCard` Т‑Касса отправляет POST-запрос с информацией о привязке карты. Нотификация отправляется на ресурс Мерчанта на адрес `Notification URL` синхронно и ожидает ответа в течение 10 секунд.
	 * После получения ответа или неполучения его за заданное время сервис переадресует клиента на `Success AddCard URL` или `Fail AddCard URL` в зависимости от результата привязки карты.
	 * В случае успешной обработки нотификации Мерчант должен вернуть ответ с телом сообщения: OK (без тегов и заглавными английскими буквами). <br>
	 * Если тело сообщения отлично от **OK**, любая нотификация считается неуспешной, и сервис будет повторно отправлять нотификацию раз в час в течение 24 часов. Если нотификация за это время так и не доставлена, она складывается в дамп
	 *
	 * > **Нотификация о фискализации (NotificationFiscalization)**
	 * <br> Если используется подключенная онлайн касса, по результату фискализации будет
	 * отправлена нотификация с фискальными данными
	 *
	 * > **Нотификация о статусе привязки счета по QR (NotificationQr)**
	 * <br> После привязки счета по QR, магазину отправляется статус привязки и токен.
	 * Нотификация будет приходить по статусам **ACTIVE** и **INACTIVE**
	 *
	 *
	 * @tags Нотификации Мерчанта об операциях
	 * @summary Нотификации
	 */
	notification() {
		return 1;
	}
	/**
	 * * Получение deeplink с включенным подписанным JWT-токеном. Предназначен для запроса по API
	 *
	 * @tags Оплата через MirPay
	 * @summary Получить DeepLink
	 */
	getDeepLink() {
		return 1;
	}
	/**
	 * * Метод определяет доступность методов оплаты на терминале для SDK и API. Запрос не шифруется токеном
	 *
	 * @tags Оплата через MirPay
	 * @summary Проверить доступность методов на SDK
	 */
	getTerminalPayMethods() {
		return 1;
	}
	/**
	 * * Справку по конкретной операции можно получить на: <br> 1. URL-сервиса, развернутого на своей стороне. <br> 2. Электронную почту. <br> Для формирования токена необходимо использовать только <b>PASSWORD<\/b> и <b>TERMINAL_KEY<\/b>
	 *
	 * @tags Стандартный платеж
	 * @summary Получение справки по операции
	 */
	getConfirmOperation() {
		return 1;
	}
	/** @generated stop-generate-methods */
}
